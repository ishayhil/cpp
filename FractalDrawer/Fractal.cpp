//
// Created by Ishay Hil on 30/12/2019.
//

#include "Fractal.h"
#include <cmath>

// ********************** Fractal ********************** //
/**
     * The constructor. Accepts an integer (dim) between 1 and 6.
     * @param dim
*/
Fractal::Fractal(int dim)
    : dim(dim)
{}

/**
 * prints this fractal to stdout.
*/
void Fractal::print()
{
    int len = pow(_getTemplateSize(), dim);
    for (int i = 0; i < len; ++i)
    {
        if (i != len - 1)
        {
            std::cout << fractalLines.at(i) << std::endl;
        }
        else
        {
            std::cout << fractalLines.at(i);
        }
    }
}

/**
    * populates the fractalLines vector.
*/
void Fractal::populate()
{
    if (dim == 1)
    {
        this->fractalLines = _getTemplate();
        return;
    }

    int len = pow(_getTemplateSize(), dim - 1);
    Fractal *prev = _prevDim();
    prev->populate();

    std::string space;
    for (int i = 0; i < len; ++i)
    {
        space += EMPTY_SPACE;
    }

    std::vector<std::string> fTemplate = _getTemplate();

    for (int j = 0; j < _getTemplateSize(); ++j)
    {
        _generateRow(prev, len, j, space);
    }
    delete prev;
}

/**
 * Generates a new row (old times templateSize)
 * @param prev fractal for last dim
 * @param len last dim fractal matrix rank
 * @param row which row to generate
 * @param space string of spaces to add
 */
void Fractal::_generateRow(Fractal *prev, int len, int row, std::string &space)
{
    std::vector<std::string> fTemplate = _getTemplate();
    std::string str;
    for (int i = 0; i < len; ++i)
    {
        for (int j = 0; j < _getTemplateSize(); ++j)
        {
            if (fTemplate[row][j] == BASE_CHAR)
            {
                str += prev->fractalLines.at(i);
            }
            else
            {
                str += space;
            }
        }
        fractalLines.push_back(str);
        str = "";
    }
}

// ********************** SierpinskiCarpet ********************** //

/**
    * The constructor. Accepts an integer (dim) between 1 and 6.
    * @param dim
*/
SierpinskiCarpet::SierpinskiCarpet(int dim)
    : Fractal(dim)
{}

/**
    * @return the template size of the fractal.
*/
int SierpinskiCarpet::_getTemplateSize() const
{
    return 3;
}

/**
    * @return the fractal's template.
*/
std::vector<std::string> SierpinskiCarpet::_getTemplate() const
{
    return std::vector<std::string>
        {
            "###",
            "# #",
            "###"
        };
}

/**
    * @return a pointer to a fractal of the current dim with dim-1.
*/
Fractal *SierpinskiCarpet::_prevDim()
{
    return new SierpinskiCarpet(dim - 1);
}

// ********************** SierpinskiTriangle ********************** //
/**
     * The constructor. Accepts an integer (dim) between 1 and 6.
     * @param dim
*/
SierpinskiTriangle::SierpinskiTriangle(int dim)
    : Fractal(dim)
{}

/**
     * @return the template size of the fractal.
*/
int SierpinskiTriangle::_getTemplateSize() const
{
    return 2;
}

/**
 * @return the fractal's template.
*/
std::vector<std::string> SierpinskiTriangle::_getTemplate() const
{
    return std::vector<std::string>
        {
            "##",
            "# ",
        };
}

/**
   * @return a pointer to a fractal of the current dim with dim-1.
*/
Fractal *SierpinskiTriangle::_prevDim()
{
    return new SierpinskiTriangle(dim - 1);
}

// ********************** Vicsek ********************** //
/**
 * The constructor. Accepts an integer (dim) between 1 and 6.
 * @param dim
 */
Vicsek::Vicsek(int dim)
    : Fractal(dim)
{}

/**
 * @return the template size of the fractal.
 */
int Vicsek::_getTemplateSize() const
{
    return 3;
}

/**
 * @return the fractal's template.
 */
std::vector<std::string> Vicsek::_getTemplate() const
{
    return std::vector<std::string>
        {
            "# #",
            " # ",
            "# #",
        };
}

/**
 * @return a pointer to a fractal of the current dim with dim-1.
*/
Fractal *Vicsek::_prevDim()
{
    return new Vicsek(dim - 1);
}

// ********************** FractalFactory ********************** //
/**
 * the fractals generated by the factory
*/
std::vector<Fractal *> FractalFactory::fractals;

/**
 * parses the csv in the given path, ang generates the fractals.
 * @param path
 */
void FractalFactory::parseCsv(std::string &path)
{
    if (!boost::filesystem::exists(path))
    {
        invalidInput();
    }
    std::ifstream ifstream(path);
    typedef boost::tokenizer<boost::char_separator<char>> tokenizer;
    boost::char_separator<char> sep{COMMA_STR};
    std::string currentLine;
    if (ifstream.peek() == std::ifstream::traits_type::eof())
    { // empty file
        ifstream.close();
        return;
    }
    while (getline(ifstream, currentLine))
    { // in line
        tokenizer tok{currentLine, sep};
        if (currentLine.empty() || !_checkNotDupComma(currentLine))
        {
            deleteFractals();
            ifstream.close();
            invalidInput();
        }
        std::vector<std::string> tokens;
        for (const auto &t: tok)
        {
            tokens.push_back(t);
        }
        _generateFractals(tokens, ifstream);
    }
    ifstream.close();
}

/**
 * prints invalid csv input message and exists the program with exit failure.
 */
void FractalFactory::invalidInput()
{
    std::cerr << INVALID_INPUT << std::endl;
    exit(EXIT_FAILURE);
}

/**
 * allocates the fractals
 * @param fractalsVector vector of (fractal_type, dim)
 * @param ifstream csv stream
 */
void FractalFactory::_generateFractals(std::vector<std::string> &fractalsVector, std::ifstream &ifstream)
{
    if (fractalsVector.size() != 2 || !_isValidVector(fractalsVector)) // if csv structure is invalid
    {
        deleteFractals();
        ifstream.close();
        invalidInput();
    }
    int fractalNum = std::stoi(fractalsVector[0]);
    int dim = std::stoi(fractalsVector[1]);
    if (fractalNum < 1 || fractalNum > 3 || dim < 1 || dim > 6) // if values are invalid
    {
        deleteFractals();
        ifstream.close();
        invalidInput();
    }
    switch (fractalNum)
    {
        case 1: FractalFactory::fractals.push_back(new SierpinskiCarpet(dim));
            break;
        case 2: FractalFactory::fractals.push_back(new SierpinskiTriangle(dim));
            break;
        default: FractalFactory::fractals.push_back(new Vicsek(dim)); // case 3
    }
}

/**
 * checks if the vector is valid (size, no empty lines, decimal only, 1 char)
 * @param v the vector
 * @return true if vector is valid, false otherwise
 */
bool FractalFactory::_isValidVector(std::vector<std::string> &v)
{
    for (std::string string: v)
    {
        if (string.empty())
        {
            return false;
        }
        if (string[string.size() - 1] == '\r')
        {
            string.erase(string.size() - 1);
        }
        if (string.size() != 1 || !isdigit((unsigned char) string[0]))
        {
            return false;
        }
    }
    return true;
}

/**
 * @param string to check
 * @return true if the string contains duplicated commas, false otherwise.
 */
bool FractalFactory::_checkNotDupComma(std::string &string)
{
    if (string.size() == 1)
    {
        return true;
    }
    for (int i = 0; i < (int) string.size() - 1; ++i)
    {
        if (string[i] == COMMA && string[i + 1] == COMMA)
        {
            return false;
        }
    }
    return true;
}

/**
 * deletes (frees) the fractals in the vector
 */
void FractalFactory::deleteFractals()
{
    for (Fractal *fractal: FractalFactory::fractals)
    {
        delete fractal;
    }
}